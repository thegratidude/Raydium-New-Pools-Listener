import { Injectable, Logger, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { SocketService } from '../gateway/socket.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { PositionManagerService } from './position-manager.service';

interface EarlyTradingConfig {
  enabled: boolean;
  positionSize: number; // 1.0 SOL
  maxPositions: number; // 3 positions max
  paperTrading: {
    enabled: boolean;
    initialBalance: number; // 10 SOL starting balance
    successRate: number; // 95% success rate for paper trades
  };
  entryConditions: {
    minPriceIncrease: number; // 3% minimum price increase (reduced from 5%)
    minTVLIncrease: number; // 10% minimum TVL increase
    maxPoolAge: number; // 30 minutes max pool age
    minBaselineTVL: number; // 10 SOL minimum baseline TVL
  };
  exitConditions: {
    takeProfitPercent: number; // 15% take profit (reduced from 25%)
    stopLossPercent: number; // 10% stop loss (reduced from 15%)
    maxHoldTime: number; // 60 minutes max hold
    tvlExitThreshold: number; // -20% TVL drop threshold
    trailingStopLoss: {
      enabled: boolean; // Enable trailing stop loss
      activationPercent: number; // Activate trailing stop when profit reaches this % (e.g., 3%)
      trailingDistance: number; // Distance behind current price (e.g., 2%)
      breakevenLock: number; // Move to breakeven at this profit % (e.g., 8%)
    };
  };
  riskManagement: {
    maxDailyLoss: number; // 2.0 SOL daily loss limit
    maxConcurrentPositions: number; // 3 max concurrent
    minLiquidity: number; // 5.0 SOL minimum liquidity
    maxPriceImpact: number; // 2% maximum price impact
  };
  rugRecovery: {
    enabled: boolean;
    maxRecoveryPositions: number; // Max 5 recovery positions at once (increased from 2)
    recoveryPositionSize: number; // 0.2 SOL per recovery position (reduced from 0.5)
    maxRecoveryAttempts: number; // Max 8 recovery attempts per pool (increased from 3)
    recoveryCooldown: number; // 2 minutes between attempts (reduced from 10)
    takeProfitPercent: number; // 15% take profit for recovery trades (reduced from 50%)
    stopLossPercent: number; // 10% stop loss for recovery trades (reduced from 15%)
    maxHoldTime: number; // 60 minutes max hold for recovery (increased from 30)
    criteria: {
      minPriceIncrease: number; // 5% from bottom (reduced from 15%)
      minTVLIncrease: number; // 10% from bottom (reduced from 20%)
      minVolumeSpike: number; // 1.2x normal volume (reduced from 2x)
      momentumDuration: number; // 30 seconds of sustained growth (reduced from 2 minutes)
      maxRecoveryAge: number; // 4 hours max for recovery attempts (increased from 1)
      minBottomDuration: number; // Must stay at bottom for at least 30 seconds (reduced from 2 minutes)
      // NEW: V-shaped recovery detection
      vShapeRecovery: {
        enabled: boolean;
        minDrop: number; // 30% drop
        minBounce: number; // 10% bounce
        maxRecoveryTime: number; // 5 minutes
        volumeConfirmation: number; // 1.5x volume
      };
    };
  };
  // NEW: Post-exit monitoring for runner detection
  postExitMonitoring: {
    enabled: boolean;
    duration: number; // 1 hour after exit
    runnerDetection: {
      enabled: boolean;
      minPriceBounce: number; // 15% bounce from recent low
      minTVLBounce: number; // 10% TVL bounce
      volumeSpike: number; // 1.5x volume
      momentumThreshold: number; // 3% sustained growth
      maxRetracement: number; // Allow 8% retracement
      reEntrySize: number; // 0.3 SOL for runner re-entries
    };
  };
  // NEW: Enhanced re-entry strategy
  reEntryStrategy: {
    enabled: boolean;
    maxReEntries: number; // 5 re-entries (increased from 3)
    reEntryCooldown: number; // 1 minute between re-entries (reduced from 2)
    reEntryCriteria: {
      minPriceRecovery: number; // 5% recovery from stop loss
      minTVLRecovery: number; // 8% TVL recovery
      volumeConfirmation: number; // 1.3x normal volume
      momentumDuration: number; // 30 seconds of growth
    };
    // NEW: Runner momentum detection
    runnerMomentum: {
      enabled: boolean;
      minConsecutiveGrowth: number; // 3 consecutive price increases
      minGrowthRate: number; // 2% per update
      volumeAcceleration: number; // 1.2x volume increase
      maxRetracement: number; // 5% max retracement
    };
  };
}

interface EarlyPosition {
  id: string;
  poolId: string;
  entryPrice: number;
  currentPrice: number;
  baselinePrice: number;
  baselineTVL: number;
  currentTVL: number;
  entryTime: number;
  lastUpdate: number;
  
  // Position sizing
  totalInvestment: number;
  
  // Status
  status: 'entered' | 'exited' | 'stopped';
  exitReason: string;
  
  // Performance tracking
  totalPnL: number;
  totalPnLPercent: number;
  
  // Paper trading tracking
  paperTradeId: string;
  tokensPurchased: number;
  
  // Progress logging
  lastProgressLog: number;
  
  // Re-entry tracking
  isReEntry: boolean;
  originalEntryTime: number;
  reEntryCount: number;
  
  // Trailing stop loss tracking
  trailingStopActive: boolean;
  trailingStopPrice: number;
  highestPrice: number;
  highestPriceTime: number;
}

interface PoolReEntryTracker {
  poolId: string;
  successfulExits: number;
  lastExitTime: number;
  lastExitPrice: number;
  lastExitReason: string;
  reEntryCount: number;
  maxReEntries: number;
  originalEntryTime: number;
}

export interface PaperTrade {
  id: string;
  poolId: string;
  type: 'buy' | 'sell';
  price: number;
  amount: number;
  tokens?: number;
  timestamp: number;
  success: boolean;
  error?: string;
}

interface PaperPortfolio {
  balance: number; // SOL balance
  positions: Map<string, {
    poolId: string;
    tokens: number;
    entryPrice: number;
    entryAmount: number;
    entryTime: number;
  }>;
  trades: PaperTrade[];
  totalPnL: number;
  totalTrades: number;
  successfulTrades: number;
}

interface RugRecoveryTracker {
  poolId: string;
  rugTime: number;
  rugPrice: number;
  rugTVL: number;
  bottomPrice: number;
  bottomTime: number;
  recoveryAttempts: number;
  maxRecoveryAttempts: number;
  lastRecoveryAttempt: number;
  recoveryCooldown: number; // 30 minutes between recovery attempts
  isMonitoring: boolean;
  recoveryCriteria: {
    minPriceIncrease: number; // 20% from bottom
    minTVLIncrease: number; // 50% from bottom
    minVolumeSpike: number; // 3x normal volume
    momentumDuration: number; // 5 minutes of sustained growth
    maxRecoveryAge: number; // 1 hour max for recovery attempts (reduced from 4)
  };
}

interface RugRecoveryPosition {
  id: string;
  poolId: string;
  entryPrice: number;
  currentPrice: number;
  bottomPrice: number;
  entryTime: number;
  lastUpdate: number;
  investment: number; // 0.2 SOL
  tokensPurchased: number;
  status: 'active' | 'exited';
  exitReason: string;
  pnl: number;
  pnlPercent: number;
  recoveryAttempt: number;
}

// NEW: Post-exit monitoring for runner detection
interface PostExitTracker {
  poolId: string;
  exitTime: number;
  exitPrice: number;
  exitReason: string;
  bottomPrice: number;
  bottomTime: number;
  monitoringEndTime: number;
  isMonitoring: boolean;
  runnerDetectionAttempts: number;
  maxRunnerAttempts: number;
  lastRunnerAttempt: number;
  runnerCooldown: number; // 2 minutes between runner attempts
}

// NEW: Runner position tracking
interface RunnerPosition {
  id: string;
  poolId: string;
  entryPrice: number;
  currentPrice: number;
  bottomPrice: number;
  entryTime: number;
  lastUpdate: number;
  investment: number; // 0.3 SOL
  tokensPurchased: number;
  status: 'active' | 'exited';
  exitReason: string;
  pnl: number;
  pnlPercent: number;
  runnerAttempt: number;
  consecutiveGrowth: number;
  momentumScore: number;
}

// NEW: V-shape recovery detection
interface VShapeRecovery {
  poolId: string;
  dropStartPrice: number;
  dropStartTime: number;
  bottomPrice: number;
  bottomTime: number;
  recoveryStartPrice: number;
  recoveryStartTime: number;
  isDetected: boolean;
  volumeConfirmation: boolean;
  momentumScore: number;
}

@Injectable()
export class EarlyTradingStrategyService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(EarlyTradingStrategyService.name);
  
  private config: EarlyTradingConfig = {
    enabled: true,
    positionSize: 1.0,
    maxPositions: 5,
    paperTrading: {
      enabled: true,
      initialBalance: 10.0, // 10 SOL starting balance
      successRate: 0.95, // 95% success rate
    },
    entryConditions: {
      minPriceIncrease: 3, // 3% minimum price increase (reduced from 5%)
      minTVLIncrease: 10, // 10% minimum TVL increase
      maxPoolAge: 30, // 30 minutes max pool age
      minBaselineTVL: 10, // 10 SOL minimum baseline TVL
    },
    exitConditions: {
      takeProfitPercent: 15, // 15% take profit (reduced from 25%)
      stopLossPercent: 10, // 10% stop loss (reduced from 15%)
      maxHoldTime: 60, // 60 minutes max hold
      tvlExitThreshold: -20, // -20% TVL drop threshold
      trailingStopLoss: {
        enabled: true, // Enable trailing stop loss
        activationPercent: 3, // Activate trailing stop when profit reaches this % (e.g., 3%)
        trailingDistance: 2, // Distance behind current price (e.g., 2%)
        breakevenLock: 8, // Move to breakeven at this profit % (e.g., 8%)
      },
    },
    riskManagement: {
      maxDailyLoss: 2.0,
      maxConcurrentPositions: 3,
      minLiquidity: 5.0,
      maxPriceImpact: 2,
    },
    rugRecovery: {
      enabled: true,
      maxRecoveryPositions: 5, // Max 5 recovery positions at once (increased from 2)
      recoveryPositionSize: 0.2, // 0.2 SOL per recovery position (reduced from 0.5)
      maxRecoveryAttempts: 8, // Max 8 recovery attempts per pool (increased from 3)
      recoveryCooldown: 2 * 60 * 1000, // 2 minutes between attempts (reduced from 10)
      takeProfitPercent: 15, // 15% take profit for recovery trades (reduced from 50%)
      stopLossPercent: 10, // 10% stop loss for recovery trades (reduced from 15%)
      maxHoldTime: 60 * 60 * 1000, // 60 minutes max hold for recovery (increased from 30)
      criteria: {
        minPriceIncrease: 5, // 5% from bottom (reduced from 15%)
        minTVLIncrease: 10, // 10% from bottom (reduced from 20%)
        minVolumeSpike: 1.2, // 1.2x normal volume (reduced from 2x)
        momentumDuration: 30 * 1000, // 30 seconds of sustained growth (reduced from 2 minutes)
        maxRecoveryAge: 4 * 60 * 60 * 1000, // 4 hours max for recovery attempts (increased from 1)
        minBottomDuration: 30 * 1000, // Must stay at bottom for at least 30 seconds (reduced from 2 minutes)
        // NEW: V-shaped recovery detection
        vShapeRecovery: {
          enabled: false,
          minDrop: 30, // 30% drop
          minBounce: 10, // 10% bounce
          maxRecoveryTime: 5 * 60 * 1000, // 5 minutes
          volumeConfirmation: 1.5, // 1.5x volume
        },
      },
    },
    postExitMonitoring: {
      enabled: true,
      duration: 60 * 60 * 1000, // 1 hour after exit
      runnerDetection: {
        enabled: true,
        minPriceBounce: 15, // 15% bounce from recent low
        minTVLBounce: 10, // 10% TVL bounce
        volumeSpike: 1.5, // 1.5x volume
        momentumThreshold: 3, // 3% sustained growth
        maxRetracement: 8, // Allow 8% retracement
        reEntrySize: 0.3, // 0.3 SOL for runner re-entries
      },
    },
    reEntryStrategy: {
      enabled: true,
      maxReEntries: 5, // 5 re-entries (increased from 3)
      reEntryCooldown: 60 * 1000, // 1 minute between re-entries (reduced from 2)
      reEntryCriteria: {
        minPriceRecovery: 5, // 5% recovery from stop loss
        minTVLRecovery: 8, // 8% TVL recovery
        volumeConfirmation: 1.3, // 1.3x normal volume
        momentumDuration: 30 * 1000, // 30 seconds of growth
      },
      // NEW: Runner momentum detection
      runnerMomentum: {
        enabled: true,
        minConsecutiveGrowth: 3, // 3 consecutive price increases
        minGrowthRate: 2, // 2% per update
        volumeAcceleration: 1.2, // 1.2x volume increase
        maxRetracement: 5, // 5% max retracement
      },
    },
  };

  private activePositions: Map<string, EarlyPosition> = new Map();
  private poolReEntryTrackers: Map<string, PoolReEntryTracker> = new Map();
  private rugRecoveryTrackers: Map<string, RugRecoveryTracker> = new Map();
  private rugRecoveryPositions: Map<string, RugRecoveryPosition> = new Map();
  // NEW: Enhanced tracking for Phase 1
  private postExitTrackers: Map<string, PostExitTracker> = new Map();
  private runnerPositions: Map<string, RunnerPosition> = new Map();
  private vShapeRecoveries: Map<string, VShapeRecovery> = new Map();
  
  // Timer tracking for graceful shutdown
  private backgroundTimers: NodeJS.Timeout[] = [];
  
  // Logging tracking
  private lastNoPositionsLog: number = 0;
  
  private paperPortfolio: PaperPortfolio = {
    balance: 10.0, // Start with 10 SOL
    positions: new Map(),
    trades: [],
    totalPnL: 0,
    totalTrades: 0,
    successfulTrades: 0,
  };
  private dailyStats = {
    totalTrades: 0,
    successfulTrades: 0,
    failedTrades: 0,
    totalPnL: 0,
    dailyLoss: 0,
    lastReset: Date.now(),
  };

  constructor(
    private readonly positionManager: PositionManagerService,
    private readonly eventEmitter: EventEmitter2
  ) {}

  async onModuleInit() {
    this.logger.log('üöÄ Initializing Early Trading Strategy Service...');
    
    // Set up event listeners
    this.setupEventListeners();
    
    // Re-initialize monitoring for any existing positions (in case of server restart)
    this.reinitializePositionMonitoring();
    
    // Start background monitoring
    this.startBackgroundMonitoring();
    
    this.logger.log('‚úÖ Early Trading Strategy Service initialized');
    this.logger.log(`üí∞ Paper Trading Portfolio: ${this.paperPortfolio.balance.toFixed(4)} SOL balance`);
  }

  private setupEventListeners() {
    // Listen for pool metrics updates
    this.eventEmitter.on('pool_metrics_update', this.handlePoolMetricsUpdate.bind(this));
    
    // Listen for arbitrage opportunities
    this.eventEmitter.on('arbitrage_opportunity', this.handleArbitrageOpportunity.bind(this));
    
    // Listen for rug detection events
    this.eventEmitter.on('rug_detected', this.handleRugDetection.bind(this));
    
    // Listen for rug recovery updates
    this.eventEmitter.on('rug_recovery_update', this.handleRugRecoveryUpdate.bind(this));
  }

  private startBackgroundMonitoring() {
    // Monitor positions every 10 seconds for early trading
    const positionTimer = setInterval(() => {
      this.monitorActivePositions();
    }, 10000);
    this.backgroundTimers.push(positionTimer);

    // Monitor rug recovery every 30 seconds
    const rugRecoveryTimer = setInterval(() => {
      this.monitorRugRecovery();
    }, 30000);
    this.backgroundTimers.push(rugRecoveryTimer);

    // NEW: Monitor post-exit tracking every 15 seconds for runner detection
    const postExitTimer = setInterval(() => {
      this.monitorPostExitTracking();
    }, 15000);
    this.backgroundTimers.push(postExitTimer);

    // NEW: Monitor runner positions every 10 seconds
    const runnerTimer = setInterval(() => {
      this.monitorRunnerPositions();
    }, 10000);
    this.backgroundTimers.push(runnerTimer);

    // NEW: Monitor V-shape recoveries every 20 seconds
    const vShapeTimer = setInterval(() => {
      this.monitorVShapeRecoveries();
    }, 20000);
    this.backgroundTimers.push(vShapeTimer);

    // Reset daily stats every 24 hours
    const dailyStatsTimer = setInterval(() => {
      this.resetDailyStats();
    }, 24 * 60 * 60 * 1000);
    this.backgroundTimers.push(dailyStatsTimer);
  }

  private monitorRugRecovery() {
    // This method will be called every 30 seconds to check rug recovery status
    // The actual monitoring logic is in handleRugRecoveryUpdate
    // Running silently in the background - no periodic logging
  }

  // NEW: Monitor post-exit tracking for runner detection
  private monitorPostExitTracking() {
    const now = Date.now();
    
    for (const [poolId, tracker] of this.postExitTrackers.entries()) {
      // Check if monitoring period has expired
      if (now > tracker.monitoringEndTime) {
        this.logger.log(`‚è∞ Post-exit monitoring expired for pool ${poolId} - stopping runner detection`);
        this.postExitTrackers.delete(poolId);
        continue;
      }

      // Check if we can attempt another runner detection
      if (tracker.isMonitoring && 
          tracker.runnerDetectionAttempts < tracker.maxRunnerAttempts &&
          now - tracker.lastRunnerAttempt >= tracker.runnerCooldown) {
        
        // This will be handled by handlePoolMetricsUpdate when new data comes in
        // Just log that we're ready for runner detection
        if (now - tracker.lastRunnerAttempt >= tracker.runnerCooldown * 2) {
          this.logger.log(`üéØ Ready for runner detection on pool ${poolId} (attempt ${tracker.runnerDetectionAttempts + 1}/${tracker.maxRunnerAttempts})`);
        }
      }
    }
  }

  // NEW: Monitor runner positions
  private monitorRunnerPositions() {
    for (const [positionId, position] of this.runnerPositions.entries()) {
      if (position.status === 'active') {
        // Check exit conditions for runner positions
        this.checkRunnerExitConditions(position);
      }
    }
  }

  // NEW: Monitor V-shape recoveries
  private monitorVShapeRecoveries() {
    const now = Date.now();
    
    for (const [poolId, vShape] of this.vShapeRecoveries.entries()) {
      // Check if V-shape recovery time has expired
      if (vShape.recoveryStartTime && 
          now - vShape.recoveryStartTime > this.config.rugRecovery.criteria.vShapeRecovery.maxRecoveryTime) {
        this.logger.log(`‚è∞ V-shape recovery time expired for pool ${poolId} - removing from tracking`);
        this.vShapeRecoveries.delete(poolId);
        continue;
      }

      // If V-shape is detected and confirmed, attempt recovery
      if (vShape.isDetected && vShape.volumeConfirmation && !vShape.recoveryStartTime) {
        this.logger.log(`üìà V-shape recovery confirmed for pool ${poolId} - attempting recovery entry`);
        vShape.recoveryStartTime = now;
        // This will trigger recovery logic in handleRugRecoveryUpdate
      }
    }
  }

  private handlePoolMetricsUpdate(data: any) {
    const { poolId, currentPrice, baselinePrice, currentTVL, baselineTVL, priceChangePercent, tvlChangePercent } = data;
    
    // Check if this pool meets early entry conditions
    if (this.shouldEnterEarlyPosition(data)) {
      this.enterEarlyPosition(poolId, data);
    }
    
    // Update existing positions
    const position = this.activePositions.get(poolId);
    if (position) {
      this.updatePosition(position, data);
    }

    // NEW: Handle post-exit monitoring for runner detection
    const postExitTracker = this.postExitTrackers.get(poolId);
    if (postExitTracker && postExitTracker.isMonitoring) {
      this.handlePostExitUpdate(poolId, data, postExitTracker);
    }

    // NEW: Handle V-shape recovery detection
    const vShapeRecovery = this.vShapeRecoveries.get(poolId);
    if (vShapeRecovery) {
      this.handleVShapeRecoveryUpdate(poolId, data, vShapeRecovery);
    }
  }

  private handleArbitrageOpportunity(data: any) {
    const { poolId, confidence, priceChangePercent } = data;
    
    // Only enter if we have high confidence and meet our criteria
    if (confidence === 'high' && priceChangePercent >= this.config.entryConditions.minPriceIncrease) {
      this.logger.log(`üéØ High confidence arbitrage opportunity for pool ${poolId}: ${priceChangePercent.toFixed(2)}% price increase`);
      
      // Check if we can take a position
      if (this.canTakeNewPosition()) {
        this.enterEarlyPosition(poolId, data);
      }
    }
  }

  private handleRugDetection(data: any) {
    const { pool_id, reason, timestamp, baseline_tvl, baseline_price, last_tvl, last_price } = data;
    
    this.logger.log(`üö® RUG DETECTED: Pool ${pool_id} - Immediate position exit required`);
    this.logger.log(`   Reason: ${reason}`);
    this.logger.log(`   Baseline TVL: ${baseline_tvl.toFixed(2)} SOL`);
    this.logger.log(`   Last TVL: ${last_tvl.toFixed(2)} SOL`);
    this.logger.log(`   Baseline Price: ${baseline_price.toFixed(8)} SOL`);
    this.logger.log(`   Last Price: ${last_price.toFixed(8)} SOL`);
    
    // Check if we have an active position in this pool
    const position = this.activePositions.get(pool_id);
    if (!position) {
      this.logger.log(`‚ÑπÔ∏è No active position found for pool ${pool_id}`);
      return;
    }
    
    // Immediately exit the position
    this.logger.log(`üö® EMERGENCY EXIT: Exiting position for rugged pool ${pool_id}`);
    this.executeFullExit(position, 'rug_detection', `Rug detected - TVL dropped below threshold. Baseline: ${baseline_tvl.toFixed(2)} SOL, Last: ${last_tvl.toFixed(2)} SOL`);
    
    // Remove from active positions
    this.activePositions.delete(pool_id);
    
    // Start monitoring for recovery
    this.startRugRecoveryMonitoring(pool_id, last_price, last_tvl, timestamp);
    
    // Update daily stats
    this.dailyStats.failedTrades++;
    
    this.logger.log(`‚úÖ Emergency exit completed for pool ${pool_id}`);
  }

  private startRugRecoveryMonitoring(poolId: string, rugPrice: number, rugTVL: number, rugTime: number) {
    if (!this.config.rugRecovery.enabled) {
      this.logger.log(`üö´ Rug recovery monitoring disabled for pool ${poolId}`);
      return;
    }

    // Check if we're already monitoring this pool
    if (this.rugRecoveryTrackers.has(poolId)) {
      this.logger.log(`‚ÑπÔ∏è Already monitoring pool ${poolId} for recovery`);
      return;
    }

    // Check if we have room for more recovery positions
    if (this.rugRecoveryPositions.size >= this.config.rugRecovery.maxRecoveryPositions) {
      this.logger.log(`üö´ Max recovery positions reached (${this.config.rugRecovery.maxRecoveryPositions}) - not monitoring ${poolId}`);
      return;
    }

    const tracker: RugRecoveryTracker = {
      poolId,
      rugTime,
      rugPrice,
      rugTVL,
      bottomPrice: rugPrice, // Will be updated as we find lower prices
      bottomTime: rugTime,
      recoveryAttempts: 0,
      maxRecoveryAttempts: this.config.rugRecovery.maxRecoveryAttempts,
      lastRecoveryAttempt: 0,
      recoveryCooldown: this.config.rugRecovery.recoveryCooldown,
      isMonitoring: true,
      recoveryCriteria: {
        minPriceIncrease: this.config.rugRecovery.criteria.minPriceIncrease,
        minTVLIncrease: this.config.rugRecovery.criteria.minTVLIncrease,
        minVolumeSpike: this.config.rugRecovery.criteria.minVolumeSpike,
        momentumDuration: this.config.rugRecovery.criteria.momentumDuration,
        maxRecoveryAge: this.config.rugRecovery.criteria.maxRecoveryAge,
      },
    };

    this.rugRecoveryTrackers.set(poolId, tracker);
    
    this.logger.log(`üîç STARTED RUG RECOVERY MONITORING: Pool ${poolId}`);
    this.logger.log(`   Rug Price: ${rugPrice.toFixed(8)} SOL`);
    this.logger.log(`   Rug TVL: ${rugTVL.toFixed(2)} SOL`);
    this.logger.log(`   Max Recovery Attempts: ${tracker.maxRecoveryAttempts}`);
    this.logger.log(`   Recovery Cooldown: ${tracker.recoveryCooldown / 1000 / 60} minutes`);
    this.logger.log(`   Monitoring Duration: 1 hour (will stop automatically)`);
    this.logger.log(`   Monitoring will continue silently in the background...`);
  }

  private handleRugRecoveryUpdate(data: any) {
    const { poolId, currentPrice, currentTVL, volume24h, priceChange24h } = data;
    
    const tracker = this.rugRecoveryTrackers.get(poolId);
    if (!tracker || !tracker.isMonitoring) {
      return;
    }

    const now = Date.now();
    
    // Check if recovery monitoring has expired
    if (now - tracker.rugTime > tracker.recoveryCriteria.maxRecoveryAge) {
      this.logger.log(`‚è∞ RUG RECOVERY MONITORING EXPIRED: Pool ${poolId} (1 hour limit reached)`);
      this.stopRugRecoveryMonitoring(poolId, 'monitoring_expired');
      return;
    }

    // Update bottom price if we find a lower price
    if (currentPrice < tracker.bottomPrice) {
      tracker.bottomPrice = currentPrice;
      tracker.bottomTime = now;
      // Silently update bottom price without logging
    }

    // Check if we should attempt recovery
    if (this.shouldAttemptRugRecovery(tracker, data)) {
      this.attemptRugRecovery(poolId, tracker, data);
    }

    // Update existing recovery positions
    const recoveryPosition = this.rugRecoveryPositions.get(poolId);
    if (recoveryPosition) {
      this.updateRugRecoveryPosition(recoveryPosition, data);
    }
  }

  // NEW: Handle post-exit monitoring updates
  private handlePostExitUpdate(poolId: string, data: any, tracker: PostExitTracker) {
    const { currentPrice, currentTVL, volume24h } = data;
    const now = Date.now();

    // Update bottom price if we find a lower price
    if (currentPrice < tracker.bottomPrice) {
      tracker.bottomPrice = currentPrice;
      tracker.bottomTime = now;
    }

    // Check if we should attempt runner detection
    if (this.shouldAttemptRunnerDetection(tracker, data)) {
      this.attemptRunnerDetection(poolId, tracker, data);
    }

    // Update existing runner positions
    const runnerPosition = this.runnerPositions.get(poolId);
    if (runnerPosition) {
      this.updateRunnerPosition(runnerPosition, data);
    }
  }

  // NEW: Handle V-shape recovery updates
  private handleVShapeRecoveryUpdate(poolId: string, data: any, vShape: VShapeRecovery) {
    const { currentPrice, volume24h } = data;
    const now = Date.now();

    // If we haven't detected the drop yet, check for significant price drop
    if (!vShape.isDetected) {
      const priceDrop = ((vShape.dropStartPrice - currentPrice) / vShape.dropStartPrice) * 100;
      
      if (priceDrop >= this.config.rugRecovery.criteria.vShapeRecovery.minDrop) {
        vShape.bottomPrice = currentPrice;
        vShape.bottomTime = now;
        vShape.isDetected = true;
        
        this.logger.log(`üìâ V-SHAPE DROP DETECTED: Pool ${poolId}`);
        this.logger.log(`   Drop: ${priceDrop.toFixed(2)}% (min: ${this.config.rugRecovery.criteria.vShapeRecovery.minDrop}%)`);
        this.logger.log(`   Bottom Price: ${currentPrice.toFixed(8)} SOL`);
      }
    } else if (!vShape.volumeConfirmation) {
      // Check for volume confirmation
      if (volume24h > 0) { // We'll need to implement proper volume tracking
        vShape.volumeConfirmation = true;
        this.logger.log(`üìä V-SHAPE VOLUME CONFIRMED: Pool ${poolId}`);
      }
    } else if (!vShape.recoveryStartTime) {
      // Check for bounce from bottom
      const bounce = ((currentPrice - vShape.bottomPrice) / vShape.bottomPrice) * 100;
      
      if (bounce >= this.config.rugRecovery.criteria.vShapeRecovery.minBounce) {
        vShape.recoveryStartPrice = currentPrice;
        vShape.recoveryStartTime = now;
        
        this.logger.log(`üìà V-SHAPE RECOVERY STARTED: Pool ${poolId}`);
        this.logger.log(`   Bounce: ${bounce.toFixed(2)}% (min: ${this.config.rugRecovery.criteria.vShapeRecovery.minBounce}%)`);
        this.logger.log(`   Recovery Price: ${currentPrice.toFixed(8)} SOL`);
      }
    }
  }

  private shouldAttemptRugRecovery(tracker: RugRecoveryTracker, data: any): boolean {
    const { currentPrice, currentTVL, volume24h, priceChange24h } = data;
    const now = Date.now();

    // Check if we've reached max attempts
    if (tracker.recoveryAttempts >= tracker.maxRecoveryAttempts) {
      return false;
    }

    // Check cooldown period
    if (now - tracker.lastRecoveryAttempt < tracker.recoveryCooldown) {
      return false;
    }

    // Check if we have room for more recovery positions
    if (this.rugRecoveryPositions.size >= this.config.rugRecovery.maxRecoveryPositions) {
      return false;
    }

    // Check if we have enough balance
    if (this.paperPortfolio.balance < this.config.rugRecovery.recoveryPositionSize) {
      return false;
    }

    // Check minimum bottom duration
    if (now - tracker.bottomTime < this.config.rugRecovery.criteria.minBottomDuration) {
      return false;
    }

    // Calculate recovery metrics
    const priceIncreaseFromBottom = ((currentPrice - tracker.bottomPrice) / tracker.bottomPrice) * 100;
    const tvlIncreaseFromBottom = ((currentTVL - tracker.rugTVL) / tracker.rugTVL) * 100;

    // Check recovery criteria
    const meetsPriceCondition = priceIncreaseFromBottom >= tracker.recoveryCriteria.minPriceIncrease;
    const meetsTVLCondition = tvlIncreaseFromBottom >= tracker.recoveryCriteria.minTVLIncrease;
    const meetsVolumeCondition = volume24h > 0; // We'll need to implement volume tracking

    if (meetsPriceCondition && meetsTVLCondition && meetsVolumeCondition) {
      this.logger.log(`üéØ RUG RECOVERY CRITERIA MET: Pool ${tracker.poolId}`);
      this.logger.log(`   Price increase from bottom: ${priceIncreaseFromBottom.toFixed(2)}% (min: ${tracker.recoveryCriteria.minPriceIncrease}%)`);
      this.logger.log(`   TVL increase from bottom: ${tvlIncreaseFromBottom.toFixed(2)}% (min: ${tracker.recoveryCriteria.minTVLIncrease}%)`);
      this.logger.log(`   Recovery attempt: ${tracker.recoveryAttempts + 1}/${tracker.maxRecoveryAttempts}`);
      return true;
    }

    return false;
  }

  // NEW: Check if we should attempt runner detection
  private shouldAttemptRunnerDetection(tracker: PostExitTracker, data: any): boolean {
    const { currentPrice, currentTVL, volume24h } = data;
    const now = Date.now();

    // Check if we've reached max attempts
    if (tracker.runnerDetectionAttempts >= tracker.maxRunnerAttempts) {
      return false;
    }

    // Check cooldown period
    if (now - tracker.lastRunnerAttempt < tracker.runnerCooldown) {
      return false;
    }

    // Check if we have enough balance
    if (this.paperPortfolio.balance < this.config.postExitMonitoring.runnerDetection.reEntrySize) {
      return false;
    }

    // Calculate bounce metrics
    const priceBounce = ((currentPrice - tracker.bottomPrice) / tracker.bottomPrice) * 100;
    const tvlBounce = ((currentTVL - tracker.bottomPrice) / tracker.bottomPrice) * 100; // Using bottom price as proxy for TVL

    // Check runner detection criteria
    const meetsPriceBounce = priceBounce >= this.config.postExitMonitoring.runnerDetection.minPriceBounce;
    const meetsTVLBounce = tvlBounce >= this.config.postExitMonitoring.runnerDetection.minTVLBounce;
    const meetsVolumeSpike = volume24h > 0; // We'll need to implement proper volume tracking

    if (meetsPriceBounce && meetsTVLBounce && meetsVolumeSpike) {
      this.logger.log(`üöÄ RUNNER DETECTION CRITERIA MET: Pool ${tracker.poolId}`);
      this.logger.log(`   Price bounce: ${priceBounce.toFixed(2)}% (min: ${this.config.postExitMonitoring.runnerDetection.minPriceBounce}%)`);
      this.logger.log(`   TVL bounce: ${tvlBounce.toFixed(2)}% (min: ${this.config.postExitMonitoring.runnerDetection.minTVLBounce}%)`);
      this.logger.log(`   Runner attempt: ${tracker.runnerDetectionAttempts + 1}/${tracker.maxRunnerAttempts}`);
      return true;
    }

    return false;
  }

  // NEW: Attempt runner detection and entry
  private attemptRunnerDetection(poolId: string, tracker: PostExitTracker, data: any) {
    const { currentPrice, currentTVL } = data;
    
    // Create runner position
    const positionId = `runner_${poolId}_${Date.now()}`;
    const investment = this.config.postExitMonitoring.runnerDetection.reEntrySize;
    const tokensPurchased = investment / currentPrice;
    
    const runnerPosition: RunnerPosition = {
      id: positionId,
      poolId,
      entryPrice: currentPrice,
      currentPrice,
      bottomPrice: tracker.bottomPrice,
      entryTime: Date.now(),
      lastUpdate: Date.now(),
      investment,
      tokensPurchased,
      status: 'active',
      exitReason: '',
      pnl: 0,
      pnlPercent: 0,
      runnerAttempt: tracker.runnerDetectionAttempts + 1,
      consecutiveGrowth: 0,
      momentumScore: 0.5, // Start with neutral momentum
    };
    
    // Execute paper buy
    const buyResult = this.executePaperBuy(poolId, currentPrice, investment);
    
    if (buyResult.success) {
      this.runnerPositions.set(positionId, runnerPosition);
      tracker.runnerDetectionAttempts++;
      tracker.lastRunnerAttempt = Date.now();
      
      this.logger.log(`üöÄ RUNNER POSITION ENTERED: Pool ${poolId}`);
      this.logger.log(`   Entry Price: ${currentPrice.toFixed(8)} SOL`);
      this.logger.log(`   Investment: ${investment.toFixed(2)} SOL`);
      this.logger.log(`   Tokens: ${tokensPurchased.toFixed(2)}`);
      this.logger.log(`   Runner Attempt: ${runnerPosition.runnerAttempt}/${tracker.maxRunnerAttempts}`);
    } else {
      this.logger.error(`‚ùå Failed to enter runner position for pool ${poolId}: ${buyResult.error}`);
    }
  }

  // NEW: Update runner position
  private updateRunnerPosition(position: RunnerPosition, data: any) {
    const { currentPrice, volume24h } = data;
    
    // Update position data
    position.currentPrice = currentPrice;
    position.lastUpdate = Date.now();
    
    // Calculate PnL
    const totalValue = position.tokensPurchased * currentPrice;
    position.pnl = totalValue - position.investment;
    position.pnlPercent = (position.pnl / position.investment) * 100;
    
    // Update momentum score
    const priceChange = ((currentPrice - position.entryPrice) / position.entryPrice) * 100;
    if (priceChange > 0) {
      position.consecutiveGrowth++;
      position.momentumScore = Math.min(1.0, position.momentumScore + 0.1);
    } else {
      position.consecutiveGrowth = 0;
      position.momentumScore = Math.max(0.0, position.momentumScore - 0.1);
    }
  }

  private attemptRugRecovery(poolId: string, tracker: RugRecoveryTracker, data: any) {
    const { currentPrice, currentTVL } = data;
    
    // Execute paper buy for recovery
    const buyResult = this.executePaperBuy(poolId, currentPrice, this.config.rugRecovery.recoveryPositionSize);
    if (!buyResult.success) {
      this.logger.error(`‚ùå Rug recovery buy failed for pool ${poolId}: ${buyResult.error}`);
      return;
    }

    // Create recovery position
    const recoveryPosition: RugRecoveryPosition = {
      id: `recovery_${poolId}_${Date.now()}`,
      poolId,
      entryPrice: currentPrice,
      currentPrice,
      bottomPrice: tracker.bottomPrice,
      entryTime: Date.now(),
      lastUpdate: Date.now(),
      investment: this.config.rugRecovery.recoveryPositionSize,
      tokensPurchased: buyResult.tokens,
      status: 'active',
      exitReason: '',
      pnl: 0,
      pnlPercent: 0,
      recoveryAttempt: tracker.recoveryAttempts + 1,
    };

    this.rugRecoveryPositions.set(poolId, recoveryPosition);
    tracker.recoveryAttempts++;
    tracker.lastRecoveryAttempt = Date.now();

    this.logger.log(`üöÄ RUG RECOVERY POSITION ENTERED: ${poolId}`);
    this.logger.log(`üí∞ Investment: ${this.config.rugRecovery.recoveryPositionSize} SOL`);
    this.logger.log(`üìä Entry Price: ${currentPrice.toFixed(8)} SOL`);
    this.logger.log(`üìâ Bottom Price: ${tracker.bottomPrice.toFixed(8)} SOL`);
    this.logger.log(`üéØ Take Profit: ${(currentPrice * (1 + this.config.rugRecovery.takeProfitPercent / 100)).toFixed(8)} SOL (+${this.config.rugRecovery.takeProfitPercent}%)`);
    this.logger.log(`üõë Stop Loss: ${(currentPrice * (1 - this.config.rugRecovery.stopLossPercent / 100)).toFixed(8)} SOL (-${this.config.rugRecovery.stopLossPercent}%)`);
    this.logger.log(`‚è∞ Max Hold Time: ${this.config.rugRecovery.maxHoldTime / 1000 / 60} minutes`);

    // Emit recovery position entered event
    this.eventEmitter.emit('rug_recovery_position_entered', {
      position_id: recoveryPosition.id,
      pool_id: poolId,
      entry_price: currentPrice,
      bottom_price: tracker.bottomPrice,
      investment: this.config.rugRecovery.recoveryPositionSize,
      recovery_attempt: recoveryPosition.recoveryAttempt,
      timestamp: Date.now()
    });
  }

  private updateRugRecoveryPosition(position: RugRecoveryPosition, data: any) {
    const { currentPrice } = data;
    
    position.currentPrice = currentPrice;
    position.lastUpdate = Date.now();
    
    // Calculate current PnL
    const priceChangePercent = ((currentPrice - position.entryPrice) / position.entryPrice) * 100;
    position.pnlPercent = priceChangePercent;
    position.pnl = (currentPrice - position.entryPrice) * position.tokensPurchased;
    
    // Check exit conditions
    this.checkRugRecoveryExitConditions(position);
  }

  private checkRugRecoveryExitConditions(position: RugRecoveryPosition) {
    const timeSinceEntry = Date.now() - position.entryTime;
    const priceChangePercent = position.pnlPercent;
    
    // Check take profit (50%)
    if (priceChangePercent >= this.config.rugRecovery.takeProfitPercent) {
      this.executeRugRecoveryExit(position, 'take_profit', `${this.config.rugRecovery.takeProfitPercent}% profit target reached`);
      return;
    }
    
    // Check stop loss (15%)
    if (priceChangePercent <= -this.config.rugRecovery.stopLossPercent) {
      this.executeRugRecoveryExit(position, 'stop_loss', `${this.config.rugRecovery.stopLossPercent}% stop loss triggered`);
      return;
    }
    
    // Check max hold time (60 minutes)
    if (timeSinceEntry >= this.config.rugRecovery.maxHoldTime) {
      this.executeRugRecoveryExit(position, 'timeout', `Max hold time of ${this.config.rugRecovery.maxHoldTime / 1000 / 60} minutes exceeded`);
      return;
    }
  }

  private executeRugRecoveryExit(position: RugRecoveryPosition, reason: string, message: string) {
    const exitPrice = position.currentPrice;
    const pnl = position.pnl;
    const pnlPercent = position.pnlPercent;
    
    // Execute paper sell
    const sellResult = this.executePaperSell(position.poolId, exitPrice, position.investment);
    
    if (sellResult.success) {
      this.logger.log(`üí∞ RUG RECOVERY EXIT: Pool ${position.poolId} - ${reason}`);
      this.logger.log(`   Entry: ${position.entryPrice.toFixed(8)} SOL`);
      this.logger.log(`   Exit: ${exitPrice.toFixed(8)} SOL`);
      this.logger.log(`   PnL: ${pnl.toFixed(4)} SOL (${pnlPercent.toFixed(2)}%)`);
      this.logger.log(`   Investment: ${position.investment.toFixed(2)} SOL`);
      this.logger.log(`   Message: ${message}`);
      
      // Update daily stats
      this.dailyStats.totalTrades++;
      if (pnl > 0) {
        this.dailyStats.successfulTrades++;
      } else {
        this.dailyStats.failedTrades++;
        this.dailyStats.dailyLoss += Math.abs(pnl);
      }
      this.dailyStats.totalPnL += pnl;
      
      // Remove from active positions
      this.rugRecoveryPositions.delete(position.id);
      
      // Check if we should continue monitoring for more recovery opportunities
      const tracker = this.rugRecoveryTrackers.get(position.poolId);
      if (tracker && tracker.recoveryAttempts < tracker.maxRecoveryAttempts) {
        this.logger.log(`üîÑ Continuing rug recovery monitoring for pool ${position.poolId} (${tracker.recoveryAttempts}/${tracker.maxRecoveryAttempts} attempts)`);
      } else {
        this.stopRugRecoveryMonitoring(position.poolId, 'max attempts reached');
      }
    } else {
      this.logger.error(`‚ùå Failed to execute rug recovery exit for pool ${position.poolId}: ${sellResult.error}`);
    }
  }

  private stopRugRecoveryMonitoring(poolId: string, reason: string) {
    const tracker = this.rugRecoveryTrackers.get(poolId);
    if (tracker) {
      tracker.isMonitoring = false;
      this.logger.log(`üõë Stopped rug recovery monitoring for pool ${poolId}: ${reason}`);
      
      // Remove tracker after a delay to allow for cleanup
      setTimeout(() => {
        this.rugRecoveryTrackers.delete(poolId);
      }, 5000);
    }
  }

  // NEW: Start post-exit monitoring for runner detection
  private startPostExitMonitoring(poolId: string, exitPrice: number, exitReason: string, pnlPercent: number) {
    const now = Date.now();
    const monitoringEndTime = now + this.config.postExitMonitoring.duration;
    
    const tracker: PostExitTracker = {
      poolId,
      exitTime: now,
      exitPrice,
      exitReason,
      bottomPrice: exitPrice, // Will be updated as we track the bottom
      bottomTime: now,
      monitoringEndTime,
      isMonitoring: true,
      runnerDetectionAttempts: 0,
      maxRunnerAttempts: 5, // Allow 5 runner detection attempts
      lastRunnerAttempt: 0,
      runnerCooldown: 2 * 60 * 1000, // 2 minutes between attempts
    };
    
    this.postExitTrackers.set(poolId, tracker);
    
    this.logger.log(`üéØ STARTED POST-EXIT MONITORING: Pool ${poolId}`);
    this.logger.log(`   Exit Price: ${exitPrice.toFixed(8)} SOL`);
    this.logger.log(`   Exit Reason: ${exitReason}`);
    this.logger.log(`   PnL: ${pnlPercent.toFixed(2)}%`);
    this.logger.log(`   Monitoring Duration: ${this.config.postExitMonitoring.duration / 1000 / 60} minutes`);
    this.logger.log(`   Runner Detection: ${this.config.postExitMonitoring.runnerDetection.enabled ? 'ENABLED' : 'DISABLED'}`);
  }

  private shouldEnterEarlyPosition(data: any): boolean {
    const { poolId, priceChangePercent, tvlChangePercent, baselineTVL } = data;
    
    // Check if we already have a position
    if (this.activePositions.has(poolId)) {
      return false;
    }
    
    // Check if we can take a new position
    if (!this.canTakeNewPosition()) {
      return false;
    }
    
    // Check re-entry eligibility
    const reEntryTracker = this.poolReEntryTrackers.get(poolId);
    if (reEntryTracker && reEntryTracker.reEntryCount >= reEntryTracker.maxReEntries) {
      // Silently skip pools that have reached maximum re-entries
      return false;
    }
    
    // Check entry conditions
    const meetsPriceCondition = priceChangePercent >= this.config.entryConditions.minPriceIncrease;
    const meetsTVLCondition = tvlChangePercent >= this.config.entryConditions.minTVLIncrease;
    const meetsTVLThreshold = baselineTVL >= this.config.entryConditions.minBaselineTVL;
    
    if (meetsPriceCondition && meetsTVLCondition && meetsTVLThreshold) {
      this.logger.log(`üéØ Pool ${poolId} meets early entry conditions:`);
      this.logger.log(`   Price increase: ${priceChangePercent.toFixed(2)}% (min: ${this.config.entryConditions.minPriceIncrease}%)`);
      this.logger.log(`   TVL increase: ${tvlChangePercent.toFixed(2)}% (min: ${this.config.entryConditions.minTVLIncrease}%)`);
      this.logger.log(`   Baseline TVL: ${baselineTVL.toFixed(2)} SOL (min: ${this.config.entryConditions.minBaselineTVL} SOL)`);
      
      // Log re-entry status if applicable
      if (reEntryTracker) {
        this.logger.log(`   üîÑ Re-entry #${reEntryTracker.reEntryCount + 1} (max: ${reEntryTracker.maxReEntries})`);
      }
      
      return true;
    }
    
    return false;
  }

  private canTakeNewPosition(): boolean {
    // Check max positions
    if (this.activePositions.size >= this.config.maxPositions) {
      return false;
    }
    
    // Check daily loss limit
    if (this.dailyStats.dailyLoss >= this.config.riskManagement.maxDailyLoss) {
      return false;
    }
    
    return true;
  }

  private enterEarlyPosition(poolId: string, data: any) {
    const { currentPrice, baselinePrice, currentTVL, baselineTVL } = data;
    
    // Check if this is a re-entry
    const reEntryTracker = this.poolReEntryTrackers.get(poolId);
    const isReEntry = reEntryTracker && reEntryTracker.successfulExits > 0;
    
    // Determine position size and exit conditions based on re-entry status
    let positionSize: number;
    let takeProfitPercent: number;
    let stopLossPercent: number;
    let maxHoldTime: number;
    
    if (isReEntry) {
      // Re-entry rules: 20% take profit, 6% stop loss, 15min max hold
      positionSize = 0.5;
      takeProfitPercent = 20;
      stopLossPercent = 6;
      maxHoldTime = 15 * 60 * 1000; // 15 minutes
      
      // Increment re-entry count
      reEntryTracker.reEntryCount++;
      
      this.logger.log(`üîÑ RE-ENTRY DETECTED: Pool ${poolId} (Re-entry #${reEntryTracker.reEntryCount})`);
      this.logger.log(`   Previous exits: ${reEntryTracker.successfulExits} successful`);
      this.logger.log(`   Last exit: ${reEntryTracker.lastExitReason} at ${reEntryTracker.lastExitPrice.toFixed(8)} SOL`);
    } else {
      // First entry rules: 25% take profit, 8% stop loss, 30min max hold
      positionSize = this.config.positionSize;
      takeProfitPercent = 25;
      stopLossPercent = 8;
      maxHoldTime = 30 * 60 * 1000; // 30 minutes
    }
    
    // Execute paper buy trade
    const buyResult = this.executePaperBuy(poolId, currentPrice, positionSize);
    if (!buyResult.success) {
      this.logger.error(`‚ùå Paper buy failed for pool ${poolId}: ${buyResult.error}`);
      return;
    }
    
    const position: EarlyPosition = {
      id: `early_${poolId}_${Date.now()}`,
      poolId,
      entryPrice: currentPrice,
      currentPrice,
      baselinePrice,
      baselineTVL,
      currentTVL,
      entryTime: Date.now(),
      lastUpdate: Date.now(),
      
      // Position sizing
      totalInvestment: positionSize,
      
      // Status
      status: 'entered',
      exitReason: '',
      
      // Performance tracking
      totalPnL: 0,
      totalPnLPercent: 0,
      
      // Paper trading tracking
      paperTradeId: buyResult.tradeId,
      tokensPurchased: buyResult.tokens,
      
      // Progress logging
      lastProgressLog: Date.now(),
      
      // Re-entry tracking
      isReEntry,
      originalEntryTime: isReEntry ? reEntryTracker.originalEntryTime || Date.now() : Date.now(),
      reEntryCount: isReEntry ? reEntryTracker.reEntryCount : 0,
      
      // Trailing stop loss tracking
      trailingStopActive: false,
      trailingStopPrice: 0,
      highestPrice: 0,
      highestPriceTime: 0,
    };

    this.activePositions.set(poolId, position);
    
    this.logger.log(`üöÄ ENTERED EARLY POSITION: ${poolId}${isReEntry ? ' (RE-ENTRY)' : ''}`);
    this.logger.log(`üí∞ Investment: ${positionSize} SOL${isReEntry ? ' (reduced size)' : ''}`);
    this.logger.log(`üìä Entry Price: ${currentPrice.toFixed(8)} SOL`);
    this.logger.log(`üìà Baseline TVL: ${baselineTVL.toFixed(2)} SOL`);
    this.logger.log(`üéØ Take Profit: ${(currentPrice * (1 + takeProfitPercent / 100)).toFixed(8)} SOL (+${takeProfitPercent}%)`);
    this.logger.log(`üõë Stop Loss: ${(currentPrice * (1 - stopLossPercent / 100)).toFixed(8)} SOL (-${stopLossPercent}%)`);
    this.logger.log(`‚è∞ Max Hold Time: ${maxHoldTime} minutes`);
    this.logger.log(`üìä Paper Trade: ${buyResult.tokens.toFixed(2)} tokens purchased for ${positionSize} SOL`);
    this.logger.log(`üí∞ Portfolio Balance: ${this.paperPortfolio.balance.toFixed(4)} SOL`);
    
    // Emit position entered event
    this.eventEmitter.emit('early_position_entered', {
      position_id: position.id,
      pool_id: poolId,
      entry_price: currentPrice,
      amount: positionSize,
      is_re_entry: isReEntry,
      timestamp: Date.now()
    });
  }

  private executePaperBuy(poolId: string, price: number, amount: number): { success: boolean; tradeId?: string; tokens?: number; error?: string } {
    try {
      // Check if we have enough balance
      if (this.paperPortfolio.balance < amount) {
        return { success: false, error: `Insufficient balance: ${this.paperPortfolio.balance.toFixed(4)} SOL < ${amount} SOL` };
      }

      // Simulate trade success/failure
      const success = Math.random() <= this.config.paperTrading.successRate;
      if (!success) {
        return { success: false, error: 'Simulated trade failure' };
      }

      // Calculate tokens purchased
      const tokens = amount / price;
      
      // Update portfolio
      this.paperPortfolio.balance -= amount;
      this.paperPortfolio.positions.set(poolId, {
        poolId,
        tokens,
        entryPrice: price,
        entryAmount: amount,
        entryTime: Date.now(),
      });

      // Record trade
      const tradeId = `paper_buy_${poolId}_${Date.now()}`;
      const trade: PaperTrade = {
        id: tradeId,
        poolId,
        type: 'buy',
        price,
        amount,
        tokens,
        timestamp: Date.now(),
        success: true,
      };
      
      this.paperPortfolio.trades.push(trade);
      this.paperPortfolio.totalTrades++;
      this.paperPortfolio.successfulTrades++;

      return { success: true, tradeId, tokens };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  private executePaperSell(poolId: string, price: number, amount: number): { success: boolean; tradeId?: string; tokens?: number; pnl?: number; error?: string } {
    try {
      const position = this.paperPortfolio.positions.get(poolId);
      if (!position) {
        return { success: false, error: `No position found for pool ${poolId}` };
      }

      // Always sell the full position
      const tokensToSell = position.tokens;
      const solValue = tokensToSell * price;
      
      // Calculate PnL
      const pnl = (price - position.entryPrice) * tokensToSell;

      // Simulate trade success/failure
      const success = Math.random() <= this.config.paperTrading.successRate;
      if (!success) {
        return { success: false, error: 'Simulated trade failure' };
      }

      // Update portfolio
      this.paperPortfolio.balance += solValue;
      this.paperPortfolio.totalPnL += pnl;

      // Full exit - remove position
      this.paperPortfolio.positions.delete(poolId);

      // Record trade
      const tradeId = `paper_sell_${poolId}_${Date.now()}`;
      const trade: PaperTrade = {
        id: tradeId,
        poolId,
        type: 'sell',
        price,
        amount: solValue,
        tokens: tokensToSell,
        timestamp: Date.now(),
        success: true,
      };
      
      this.paperPortfolio.trades.push(trade);
      this.paperPortfolio.totalTrades++;
      this.paperPortfolio.successfulTrades++;

      return { success: true, tradeId, tokens: tokensToSell, pnl };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  private updatePosition(position: EarlyPosition, data: any) {
    const { currentPrice, currentTVL } = data;
    
    position.currentPrice = currentPrice;
    position.currentTVL = currentTVL;
    position.lastUpdate = Date.now();
    
    // Calculate current PnL
    const priceChangePercent = ((currentPrice - position.entryPrice) / position.entryPrice) * 100;
    position.totalPnLPercent = priceChangePercent;
    
    // Check exit conditions
    this.checkExitConditions(position);
  }

  private checkExitConditions(position: EarlyPosition) {
    const now = Date.now();
    const timeSinceEntry = now - position.entryTime;
    const priceChangePercent = position.totalPnLPercent;
    const tvlChangePercent = ((position.currentTVL - position.baselineTVL) / position.baselineTVL) * 100;
    
    // Update highest price for trailing stop loss
    if (position.currentPrice > position.highestPrice) {
      position.highestPrice = position.currentPrice;
      position.highestPriceTime = now;
    }
    
    // Determine exit conditions based on re-entry status
    let takeProfitPercent: number;
    let stopLossPercent: number;
    let maxHoldTime: number;
    
    if (position.isReEntry) {
      // Re-entry rules: 20% take profit, 6% stop loss, 15min max hold
      takeProfitPercent = 20;
      stopLossPercent = 6;
      maxHoldTime = 15 * 60 * 1000; // 15 minutes
    } else {
      // First entry rules: 25% take profit, 8% stop loss, 30min max hold
      takeProfitPercent = 25;
      stopLossPercent = 8;
      maxHoldTime = 30 * 60 * 1000; // 30 minutes
    }
    
    // Trailing stop loss logic
    if (this.config.exitConditions.trailingStopLoss.enabled) {
      const trailingConfig = this.config.exitConditions.trailingStopLoss;
      
      // Check if trailing stop should be activated
      if (!position.trailingStopActive && priceChangePercent >= trailingConfig.activationPercent) {
        position.trailingStopActive = true;
        const trailingStopPrice = position.currentPrice * (1 - trailingConfig.trailingDistance / 100);
        position.trailingStopPrice = trailingStopPrice;
        
        this.logger.log(`üéØ TRAILING STOP ACTIVATED: ${position.poolId} at ${priceChangePercent.toFixed(2)}% profit`);
        this.logger.log(`üìä Trailing stop price: ${trailingStopPrice.toFixed(8)} SOL (${trailingConfig.trailingDistance}% behind current)`);
      }
      
      // Update trailing stop if active and price is higher
      if (position.trailingStopActive && position.currentPrice > position.highestPrice) {
        const newTrailingStopPrice = position.currentPrice * (1 - trailingConfig.trailingDistance / 100);
        
        // Only move trailing stop up, never down
        if (newTrailingStopPrice > position.trailingStopPrice) {
          position.trailingStopPrice = newTrailingStopPrice;
          this.logger.log(`üìà TRAILING STOP UPDATED: ${position.poolId} to ${newTrailingStopPrice.toFixed(8)} SOL`);
        }
      }
      
      // Check breakeven lock
      if (position.trailingStopActive && priceChangePercent >= trailingConfig.breakevenLock) {
        const breakevenPrice = position.entryPrice;
        if (position.trailingStopPrice < breakevenPrice) {
          position.trailingStopPrice = breakevenPrice;
          this.logger.log(`üîí BREAKEVEN LOCK: ${position.poolId} trailing stop moved to breakeven at ${breakevenPrice.toFixed(8)} SOL`);
        }
      }
      
      // Check trailing stop loss exit
      if (position.trailingStopActive && position.currentPrice <= position.trailingStopPrice) {
        const trailingStopPercent = ((position.trailingStopPrice - position.entryPrice) / position.entryPrice) * 100;
        this.executeFullExit(position, 'trailing_stop_loss', `Trailing stop loss triggered at ${trailingStopPercent.toFixed(2)}% profit`);
        return;
      }
    }
    
    // Check full take profit (no partial exits)
    if (priceChangePercent >= takeProfitPercent) {
      this.executeFullExit(position, 'take_profit', `${takeProfitPercent}% profit target reached`);
      return;
    }
    
    // Check stop loss (only if trailing stop is not active)
    if (!position.trailingStopActive && priceChangePercent <= -stopLossPercent) {
      this.executeFullExit(position, 'stop_loss', `${stopLossPercent}% stop loss triggered`);
      return;
    }
    
    // Check max hold time
    if (timeSinceEntry >= maxHoldTime) {
      this.executeFullExit(position, 'timeout', `Max hold time of ${maxHoldTime / 1000 / 60} minutes exceeded`);
      return;
    }
    
    // Check TVL exit threshold (-20% TVL drop)
    if (tvlChangePercent <= this.config.exitConditions.tvlExitThreshold) {
      this.executeFullExit(position, 'tvl_drop', `TVL dropped ${Math.abs(tvlChangePercent).toFixed(2)}% below threshold`);
      return;
    }
  }

  private executeFullExit(position: EarlyPosition, reason: string, message: string) {
    const currentPrice = position.currentPrice;
    const totalTokens = position.tokensPurchased;
    const totalValue = totalTokens * currentPrice;
    const totalPnL = totalValue - position.totalInvestment;
    const totalPnLPercent = position.totalPnLPercent;
    
    // Execute paper sell
    const sellResult = this.executePaperSell(position.poolId, currentPrice, position.totalInvestment);
    if (!sellResult.success) {
      this.logger.error(`‚ùå Paper sell failed for pool ${position.poolId}: ${sellResult.error}`);
      return;
    }
    
    // Update position status
    position.status = 'exited';
    position.exitReason = reason;
    position.totalPnL = totalPnL;
    position.totalPnLPercent = totalPnLPercent;
    
    // Track successful exits for re-entry eligibility
    if (totalPnLPercent > 0) {
      this.trackSuccessfulExit(position.poolId, currentPrice, reason, totalPnLPercent);
    }
    
    this.logger.log(`üéØ FULL EXIT: ${position.poolId} | ${reason.toUpperCase()}`);
    this.logger.log(`üìä Final Result: ${totalPnLPercent.toFixed(2)}% profit in ${Math.round((Date.now() - position.entryTime) / 1000 / 60)} minutes`);
    this.logger.log(`üí∞ Total PnL: ${totalPnL.toFixed(4)} SOL`);
    this.logger.log(`üí° Reason: ${message}`);
    this.logger.log(`üìä Paper Trade: ${totalTokens.toFixed(2)} tokens sold for ${totalValue.toFixed(4)} SOL`);
    this.logger.log(`üí∞ Portfolio Balance: ${this.paperPortfolio.balance.toFixed(4)} SOL`);
    
    // Remove from active positions
    this.activePositions.delete(position.poolId);
    
    // Emit position exited event
    this.eventEmitter.emit('early_position_exited', {
      position_id: position.id,
      pool_id: position.poolId,
      exit_price: currentPrice,
      pnl: totalPnL,
      pnl_percentage: totalPnLPercent,
      reason,
      is_re_entry: position.isReEntry,
      re_entry_count: position.reEntryCount,
      timestamp: Date.now()
    });
    
    // If exit was due to stop loss, emit event to stop monitoring this pool
    if (reason === 'stop_loss') {
      this.logger.log(`üõë STOP LOSS EXIT: Emitting stop monitoring event for pool ${position.poolId}`);
      this.eventEmitter.emit('stop_monitoring_pool', {
        pool_id: position.poolId,
        reason: 'stop_loss_exit',
        exit_price: currentPrice,
        pnl_percentage: totalPnLPercent,
        timestamp: Date.now()
      });
    }

    // NEW: Start post-exit monitoring for runner detection
    if (this.config.postExitMonitoring.enabled) {
      this.startPostExitMonitoring(position.poolId, currentPrice, reason, totalPnLPercent);
    }
  }
  
  private trackSuccessfulExit(poolId: string, exitPrice: number, exitReason: string, pnlPercent: number) {
    let tracker = this.poolReEntryTrackers.get(poolId);
    
    if (!tracker) {
      // Create new tracker for this pool
      tracker = {
        poolId,
        successfulExits: 0,
        lastExitTime: 0,
        lastExitPrice: 0,
        lastExitReason: '',
        reEntryCount: 0,
        maxReEntries: 1, // Only allow 1 re-entry per pool
        originalEntryTime: Date.now(),
      };
      this.poolReEntryTrackers.set(poolId, tracker);
    }
    
    // Update tracker
    tracker.successfulExits++;
    tracker.lastExitTime = Date.now();
    tracker.lastExitPrice = exitPrice;
    tracker.lastExitReason = exitReason;
    
    this.logger.log(`‚úÖ SUCCESSFUL EXIT TRACKED: Pool ${poolId}`);
    this.logger.log(`   Successful exits: ${tracker.successfulExits}`);
    this.logger.log(`   Re-entries used: ${tracker.reEntryCount}/${tracker.maxReEntries}`);
    this.logger.log(`   PnL: +${pnlPercent.toFixed(2)}%`);
    
    // Log if pool is eligible for re-entry
    if (tracker.reEntryCount < tracker.maxReEntries) {
      this.logger.log(`   üîÑ Pool eligible for re-entry (${tracker.maxReEntries - tracker.reEntryCount} remaining)`);
    }
  }

  private monitorActivePositions() {
    // This is called every 10 seconds to monitor positions
    // The actual monitoring logic is in checkExitConditions
    
    // Periodic status update with service name coloring
    const activePositions = this.activePositions.size;
    const paperPositions = this.paperPortfolio.positions.size;
    const totalPositions = activePositions + paperPositions;
    
    if (totalPositions > 0) {
      // Use logger for service name coloring
      this.logger.log(`üìä ACTIVE POSITIONS: ${totalPositions} (${activePositions} live, ${paperPositions} paper)`);
      
      // Show position details
      for (const [poolId, position] of this.activePositions.entries()) {
        const duration = Math.round((Date.now() - position.entryTime) / 1000);
        const pnl = position.totalPnL;
        const pnlPercent = position.totalPnLPercent;
        this.logger.log(`   üü† Pool: ${poolId.slice(0, 8)}... | Duration: ${duration}s | PnL: ${pnl.toFixed(4)} SOL (${pnlPercent.toFixed(2)}%)`);
      }
      
      for (const [poolId, position] of this.paperPortfolio.positions.entries()) {
        const duration = Math.round((Date.now() - position.entryTime) / 1000);
        // Calculate PnL for paper positions (they don't store current price)
        const currentPrice = 0; // We don't have current price in paper positions, so show 0
        const pnl = 0;
        const pnlPercent = 0;
        this.logger.log(`   üü† PAPER: ${poolId.slice(0, 8)}... | Duration: ${duration}s | Entry: ${position.entryPrice.toFixed(8)} SOL`);
      }
    } else {
      // Less frequent updates when no positions are active
      const now = Date.now();
      if (!this.lastNoPositionsLog || now - this.lastNoPositionsLog > 60000) { // Log every minute when no positions
        this.logger.log(`üìä No active positions - monitoring for opportunities...`);
        this.lastNoPositionsLog = now;
      }
    }
  }

  private resetDailyStats() {
    this.dailyStats = {
      totalTrades: 0,
      successfulTrades: 0,
      failedTrades: 0,
      totalPnL: 0,
      dailyLoss: 0,
      lastReset: Date.now(),
    };
    this.logger.log('üîÑ Daily stats reset');
  }

  public resetPaperPortfolio(): void {
    // Reset paper portfolio
    this.paperPortfolio = {
      balance: this.config.paperTrading.initialBalance,
      positions: new Map(),
      trades: [],
      totalPnL: 0,
      totalTrades: 0,
      successfulTrades: 0,
    };
    
    // Clear active positions
    this.activePositions.clear();
    
    // Clear re-entry trackers
    this.poolReEntryTrackers.clear();
    
    // Clear rug recovery trackers and positions
    this.rugRecoveryTrackers.clear();
    this.rugRecoveryPositions.clear();
    
    // Reset daily stats
    this.dailyStats = {
      totalTrades: 0,
      successfulTrades: 0,
      failedTrades: 0,
      totalPnL: 0,
      dailyLoss: 0,
      lastReset: Date.now(),
    };
    
    this.logger.log(`üîÑ Paper trading portfolio reset to ${this.config.paperTrading.initialBalance} SOL`);
    this.logger.log(`üîÑ Cleared ${this.activePositions.size} active positions`);
    this.logger.log(`üîÑ Cleared ${this.poolReEntryTrackers.size} re-entry trackers`);
    this.logger.log(`üîÑ Cleared ${this.rugRecoveryTrackers.size} rug recovery trackers`);
    this.logger.log(`üîÑ Cleared ${this.rugRecoveryPositions.size} rug recovery positions`);
  }

  // Public methods for status and configuration
  public getActivePositions(): EarlyPosition[] {
    return Array.from(this.activePositions.values()).filter(pos => pos.status === 'entered');
  }

  public hasActivePosition(poolId: string): boolean {
    const position = this.activePositions.get(poolId);
    return position !== undefined && position.status === 'entered';
  }

  public getDailyStats() {
    return this.dailyStats;
  }

  public getConfiguration(): EarlyTradingConfig {
    return this.config;
  }

  public getPaperPortfolio() {
    return {
      balance: this.paperPortfolio.balance,
      totalPnL: this.paperPortfolio.totalPnL,
      totalTrades: this.paperPortfolio.totalTrades,
      successfulTrades: this.paperPortfolio.successfulTrades,
      successRate: this.paperPortfolio.totalTrades > 0 ? (this.paperPortfolio.successfulTrades / this.paperPortfolio.totalTrades) * 100 : 0,
      activePositions: this.activePositions.size,
      recentTrades: this.paperPortfolio.trades.slice(-5), // Last 5 trades
    };
  }

  public updateConfiguration(updates: Partial<EarlyTradingConfig>): void {
    this.config = { ...this.config, ...updates };
    this.logger.log('üìä Early trading configuration updated');
  }

  public async getHealthStatus(): Promise<{ status: string; stats?: any }> {
    const activePositions = this.getActivePositions();
    const dailyStats = this.getDailyStats();
    const paperPortfolio = this.getPaperPortfolio();
    
    const stats = {
      activePositions: activePositions.length,
      maxPositions: this.config.maxPositions,
      dailyPnL: dailyStats.totalPnL,
      dailyLoss: dailyStats.dailyLoss,
      maxDailyLoss: this.config.riskManagement.maxDailyLoss,
      totalTrades: dailyStats.totalTrades,
      successRate: dailyStats.totalTrades > 0 ? (dailyStats.successfulTrades / dailyStats.totalTrades) * 100 : 0,
      paperTrading: {
        enabled: this.config.paperTrading.enabled,
        balance: paperPortfolio.balance,
        totalPnL: paperPortfolio.totalPnL,
        totalTrades: paperPortfolio.totalTrades,
        successRate: paperPortfolio.successRate,
        activePositions: this.activePositions.size,
      },
      rugRecovery: {
        enabled: this.config.rugRecovery.enabled,
        activeTrackers: this.rugRecoveryTrackers.size,
        activePositions: this.rugRecoveryPositions.size,
        maxPositions: this.config.rugRecovery.maxRecoveryPositions,
      },
    };
    
    const status = dailyStats.dailyLoss >= this.config.riskManagement.maxDailyLoss ? 'stopped' : 'active';
    
    return { status, stats };
  }

  private reinitializePositionMonitoring() {
    // Check if we have any active positions that need monitoring re-initialized
    const activePositionsCount = this.activePositions.size;
    const paperPositionsCount = this.paperPortfolio.positions.size;
    
    if (activePositionsCount > 0 || paperPositionsCount > 0) {
      this.logger.log(`üîÑ Re-initializing monitoring for ${activePositionsCount} active positions and ${paperPositionsCount} paper positions`);
      
      // Re-initialize monitoring for active positions
      for (const [poolId, position] of this.activePositions.entries()) {
        this.logger.log(`üîÑ Re-initializing monitoring for active position: ${poolId}`);
        // The position will be monitored by the background monitoring timer
      }
      
      // Re-initialize monitoring for paper positions
      for (const [poolId, position] of this.paperPortfolio.positions.entries()) {
        this.logger.log(`üîÑ Re-initializing monitoring for paper position: ${poolId}`);
        // The position will be monitored by the background monitoring timer
      }
      
      this.logger.log(`‚úÖ Position monitoring re-initialized for ${activePositionsCount + paperPositionsCount} positions`);
    } else {
      this.logger.log('‚ÑπÔ∏è No existing positions found - starting fresh');
    }
  }

  public isRugRecoveryEnabled(): boolean {
    return this.config.rugRecovery.enabled;
  }

  // NEW: Check exit conditions for runner positions
  private checkRunnerExitConditions(position: RunnerPosition) {
    const timeSinceEntry = Date.now() - position.entryTime;
    const priceChangePercent = position.pnlPercent;
    
    // Check take profit (25% for runners)
    if (priceChangePercent >= 25) {
      this.executeRunnerExit(position, 'take_profit', `25% profit target reached for runner position`);
      return;
    }
    
    // Check stop loss (8% for runners)
    if (priceChangePercent <= -8) {
      this.executeRunnerExit(position, 'stop_loss', `8% stop loss triggered for runner position`);
      return;
    }
    
    // Check max hold time (30 minutes for runners)
    if (timeSinceEntry >= 30 * 60 * 1000) {
      this.executeRunnerExit(position, 'timeout', `Max hold time of 30 minutes exceeded for runner position`);
      return;
    }
    
    // Check momentum loss (if momentum score drops significantly)
    if (position.momentumScore < 0.3 && timeSinceEntry > 5 * 60 * 1000) {
      this.executeRunnerExit(position, 'momentum_loss', `Momentum lost for runner position`);
      return;
    }
  }

  // NEW: Execute runner position exit
  private executeRunnerExit(position: RunnerPosition, reason: string, message: string) {
    const exitPrice = position.currentPrice;
    const pnl = position.pnl;
    const pnlPercent = position.pnlPercent;
    
    // Execute paper sell
    const sellResult = this.executePaperSell(position.poolId, exitPrice, position.investment);
    
    if (sellResult.success) {
      this.logger.log(`üöÄ RUNNER EXIT: Pool ${position.poolId} - ${reason}`);
      this.logger.log(`   Entry: ${position.entryPrice.toFixed(8)} SOL`);
      this.logger.log(`   Exit: ${exitPrice.toFixed(8)} SOL`);
      this.logger.log(`   PnL: ${pnl.toFixed(4)} SOL (${pnlPercent.toFixed(2)}%)`);
      this.logger.log(`   Investment: ${position.investment.toFixed(2)} SOL`);
      this.logger.log(`   Momentum Score: ${position.momentumScore.toFixed(2)}`);
      this.logger.log(`   Consecutive Growth: ${position.consecutiveGrowth}`);
      this.logger.log(`   Message: ${message}`);
      
      // Update daily stats
      this.dailyStats.totalTrades++;
      if (pnl > 0) {
        this.dailyStats.successfulTrades++;
      } else {
        this.dailyStats.failedTrades++;
        this.dailyStats.dailyLoss += Math.abs(pnl);
      }
      this.dailyStats.totalPnL += pnl;
      
      // Remove from active positions
      this.runnerPositions.delete(position.id);
      
      // Check if we should continue post-exit monitoring
      const tracker = this.postExitTrackers.get(position.poolId);
      if (tracker && tracker.runnerDetectionAttempts < tracker.maxRunnerAttempts) {
        this.logger.log(`üéØ Continuing runner detection for pool ${position.poolId} (${tracker.runnerDetectionAttempts}/${tracker.maxRunnerAttempts} attempts)`);
      } else {
        this.logger.log(`‚è∞ Stopping runner detection for pool ${position.poolId} - max attempts reached`);
        this.postExitTrackers.delete(position.poolId);
      }
    } else {
      this.logger.error(`‚ùå Failed to execute runner exit for pool ${position.poolId}: ${sellResult.error}`);
    }
  }

  async onModuleDestroy() {
    // Implement graceful shutdown to clear timers properly
    this.backgroundTimers.forEach(timer => clearInterval(timer));
    this.backgroundTimers = [];
  }
}